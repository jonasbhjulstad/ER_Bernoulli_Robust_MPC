#ifndef SIR_METAPOPULATION_NETWORK_SYCL_IMPL_HPP
#define SIR_METAPOPULATION_NETWORK_SYCL_IMPL_HPP
#include <oneapi/dpl/internal/random_impl/uniform_real_distribution.h>
#include <random>
#ifdef SYCL_GRAPH_USE_SYCL
#include "SIR_Metapopulation_Types.hpp"
#include <Sycl_Graph/Graph/Graph.hpp>
#include <Sycl_Graph/Network/Network.hpp>
#include <Sycl_Graph/random.hpp>
#include <Sycl_Graph/statistical_typedefs.hpp>
#include <oneapi/dpl/algorithm>
#include <oneapi/dpl/random>
#include <stddef.h>
#include <sycl/CL/sycl.hpp>
#include <type_traits>
#include <utility>
template <>
struct sycl::is_device_copyable<
    Sycl_Graph::Network_Models::SIR_Metapopulation_Node_Param>
    : std::true_type {};

template <>
struct sycl::is_device_copyable<
    Sycl_Graph::Network_Models::SIR_Metapopulation_Param> : std::true_type {};

template <>
struct sycl::is_device_copyable<
    Sycl_Graph::Network_Models::SIR_Metapopulation_State> : std::true_type {};
namespace Sycl_Graph {

namespace Sycl::Network_Models {

// sycl::is_device_copyable_v<SIR_Metapopulation_State>
// is_copyable_SIR_Invidual_State;
using namespace Sycl_Graph::Network_Models;
template <typename T> using SIR_vector_t = std::vector<T, std::allocator<T>>;
struct SIR_Metapopulation_Node {
  SIR_Metapopulation_State state;
  SIR_Metapopulation_Param param;
};
struct SIR_Metapopulation_Temporal_Param {};

using SIR_Metapopulation_Graph =
    Sycl_Graph::Sycl::Graph<SIR_Metapopulation_Node, SIR_Metapopulation_Param,
                            uint32_t>;
struct SIR_Metapopulation_Network
    : public Network<SIR_Metapopulation_Temporal_Param,
                     SIR_Metapopulation_Network> {
  using Graph_t = SIR_Metapopulation_Graph;
  using Vertex_t = typename Graph_t::Vertex_t;
  using Edge_t = typename Graph_t::Edge_t;
  using Base_t =
      Network<SIR_Metapopulation_Temporal_Param, SIR_Metapopulation_Network>;
  const uint32_t t = 0;

  sycl::buffer<int, 1> seed_buf;
  sycl::buffer<oneapi::dpl::minstd_rand, 1> rng_buf;
  std::vector<Normal_Distribution<float>> I0_dist;
  std::vector<Normal_Distribution<float>> R0_dist;

  SIR_Metapopulation_Network(Graph_t &G, const std::vector<float> &E_I0,
                             const std::vector<Normal_Distribution<>> &I0,
                             const std::vector<Normal_Distribution<>> &R0,
                             const std::vector<float> &alpha,
                             const std::vector<float> &node_beta,
                             const std::vector<float> &edge_beta,
                             int seed = 777)
      : Base_t(3), q(G.q), G(G), seed_buf(sycl::range<1>(G.NV)), I0_dist(I0),
        R0_dist(R0), rng_buf(sycl::range<1>(G.NE)) {

    generate_seeds(seed);
  }
  void initialize() {

    q.submit([&](sycl::handler &h) {
      auto seed = seed_buf.get_access<sycl::access::mode::read>(h);
      auto v = G.vertex_buf.template get_access<sycl::access::mode::write>(h);
      h.parallel_for(sycl::range<1>(G.N_vertices()), [=](sycl::id<1> id) {
        // total population stored in susceptible state
        float N_pop = v.data[id].state.S;
        Sycl_Graph::random::default_rng rng(seed[id]);
        SIR_Metapopulation_State v_i;
        v_i.I = I0_dist[id](rng) * N_pop;
        v_i.R = R0_dist[id](rng) * N_pop;
        v_i.S = N_pop - v_i.I - v_i.R;
        v.data[id].state = v_i;
      });
    });
  }

  std::vector<uint32_t> population_count() {
    std::vector<uint32_t> count(3, 0);
    sycl::buffer<uint32_t, 1> count_buf(count.data(), sycl::range<1>(3));
    const uint32_t N_vertices = G.N_vertices();

    q.submit([&](sycl::handler &h) {
      auto count_acc = count_buf.get_access<sycl::access::mode::write>(h);
      auto v = G.get_vertex_access<sycl::access::mode::read>(h);

      h.single_task([=] {
        for (int i = 0; i < N_vertices; i++) {
          count_acc[0] += v.data[i].state.S;
          count_acc[1] += v.data[i].state.I;
          count_acc[2] += v.data[i].state.R;
        }
      });
    });
    q.wait();
    sycl::host_accessor count_acc(count_buf, sycl::read_only);
    // read into vector
    std::vector<uint32_t> res(3);
    for (int i = 0; i < 3; i++) {
      res[i] = count_acc[i];
    }

    return res;
  }

  // function for infection step
  void infection_step(float p_I) {
    using Sycl_Graph::Network_Models::SIR_Metapopulation_State;

    //buffer for unmerged infections generated by vertices
    sycl::buffer<float, 1> v_inf_buf(sycl::range<1>(G.N_vertices()));


    q.submit([&](sycl::handler &h) {
      auto v_inf_acc = v_inf_buf.template get_access<sycl::access::mode::read_write>(h);
      auto rng_acc = rng_buf.get_access<sycl::access::mode::read_write>(h);
      h.parallel_for(sycl::range<1>(G.N_edges()), [=](sycl::id<1> id) {
        Sycl_Graph::random::binomial_distribution<float> d_I(v_acc.data[id].state.S,
                                                      p_I);
        auto d_S = d_I(rng[id]);
        v_inf_acc[id] = d_S;
      });
    });

    //buffer for unmerged infections generated by edges
    sycl::buffer<float, 1> v_inf_buf(sycl::range<1>(G.N_edges()));


    q.submit([&](sycl::handler &h) {
      auto v_acc = G.get_vertex_access<sycl::access::mode::read_write>(h);
      auto seed_acc = seed_buf.get_access<sycl::access::mode::read_write>(h);
      h.parallel_for(sycl::range<1>(v_acc.size()), [=](sycl::id<1> id) {
        
        Sycl_Graph::random::binomial_distribution d_I(v_acc.data[id].state.S,
                                                      p_I);
                        
      });
    });

    int a = 0;
  }

  void recovery_step(float p_R) {

    q.submit([&](sycl::handler &h) {
      auto seed_acc = seed_buf.get_access<sycl::access::mode::read_write>(h);
      auto v = G.get_vertex_access<sycl::access::mode::read_write>(h);
      sycl::stream out(1024, 256, h);
      //  auto nv = neighbors_buf.get_access<sycl::access::mode::read_write>(h);
      h.parallel_for(sycl::range<1>(G.N_vertices()), [=](sycl::id<1> id) {
        Sycl_Graph::random::default_rng rng(seed_acc[id]);
        seed_acc[id]++;
        Sycl_Graph::random::uniform_real_distribution<float> d_R(0, 1);
        if (v[id] == SIR_INDIVIDUAL_I) {
          if (d_R(rng) < p_R) {
            v[id] = SIR_INDIVIDUAL_R;
          }
        }
      });
    });
    q.wait();
  }
  void advance(const SIR_Metapopulation_Temporal_Param &p) {
    infection_step();
    recovery_step();
  }

  bool terminate(const SIR_Metapopulation_Temporal_Param &p,
                 const std::vector<uint32_t> &x) {
    bool early_termination = ((t > p.Nt_min) && (x[1] < p.N_I_min));
    return early_termination;
  }

  void reset() {
    q.submit([&](sycl::handler &h) {
      auto v = G.vertex_access(h);
      h.parallel_for(sycl::range<1>(G.N_vertices()),
                     [=](sycl::id<1> id) { v[id[0]] = SIR_INDIVIDUAL_S; });
    });
  }

private:
  void generate_seeds(int seed) {
    // generate seeds
    std::vector<int> seeds(G.NE);
    // random device
    std::random_device rd(seed);
    // mt19937 generator
    std::vector<int> seeds(G.NE);
    std::generate(seeds.begin(), seeds.end(), gen);
    q.submit([&](sycl::handler &h) {
      auto rng_acc = rng_buf.get_access<sycl::access::mode::write>(h);
      h.parallel_for(sycl::range<1>(G.NE),
                     [=](sycl::id<1> id) { rng_buf[id].seed(seeds[id]); });
    });
  }

  Graph_t &G;
  sycl::queue &q;
};
} // namespace Sycl::Network_Models
} // namespace Sycl_Graph
#endif
#endif